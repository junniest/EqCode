%
% Definition of BNF syntax rules. 
%

\newcommand{\BnfFunction}{
\bHead{function}
  \bToken{\bs begin} \bSymb{\{} \bToken{eqcode} \bSymb{\}} \bSymb{\{}
  \bSpecial{id} \bSymb{\}} \bSkip \bSymb{\{} \bOpt{id \bStar{\bSymb{,}
  id}} \bSymb{\}} \bSkip \bSymb{\{} \bOpt{ext\_type \bStar{\bSymb{,}
  ext\_type}} \bSymb{\}} \bSymb{\{} ext\_type \bSymb{\}} \bSkip
  instr\_list \bSkip
  \bToken{\bs end} \bSymb{\{} \bToken{eqcode} \bSymb{\}}
\bEnd
}

\newcommand{\BnfIdx}{
\bHead{idx}
  \bSpecial{id} indexes
\bEnd
}

\newcommand{\BnfIndexes}{
\bHead{indexes}
  \bAlt { \bOpt{upper} \bOpt{lower} } { lower upper }
\bEnd
}
\newcommand{\BnfNumx}{
\bHead{numx}
  \bSpecial{num} \bOr
  divide
\bEnd
}

\newcommand{\BnfIdxNumx}{
\bHead{idx\_numx}
  \bAlt{idx}{numx}
\bEnd
}

\newcommand{\BnfUpper}{
\bHead{upper}
  \bSymb{\^} \bSymb{\{} \bAlt{\bSymb{[} linear \bSymb{]}}{linear} \bSymb{\}}
  \bOr
  \bSymb{\^} \bAlt {\bToken{id} } {\bToken{num}}
\bEnd
}

\newcommand{\BnfLinear}{
\bHead{linear}
 \bSpecial{id} \bOpt{\bAlt{\bSymb{+}}{\bSymb{-}} \bSpecial{num}} \bOr
 \bSpecial{num}
\bEnd
}

\newcommand{\BnfLower}{
\bHead{lower}
  \bSymb{\_} \bSymb{\{} sexpr \bStar{\bSymb{,} sexpr} \bSymb{\}} \bOr
  \bSymb{\_} \bAlt {\bToken{id} } {\bToken{num}}
\bEnd
}

\newcommand{\BnfType}{
\bHead{type}
  \bToken{\bs type} \bSymb{\{} \bAltBegin \bToken{Z} \bDAlt \bToken{R} \bDAlt
  \bToken{N} \bDAlt \bToken{B} \bAltEnd \bSymb{\}}
\bEnd
}

\newcommand{\BnfExtType}{
\bHead{ext\_type}
  type \bOpt{\bSymb{\^} \bAltBegin \bSymb{\{} sexpr \bSymb{\}} \bDAlt
  \bSpecial{num} \bDAlt \bSpecial{id} \bAltEnd \bSkip \bOpt{\bSymb{\_}
  \bAltBegin \bSymb{\{} sexpr \bStar{\bSymb{,}
  sexpr} \bSymb{\}}}} \bDAlt \bSpecial{id} \bDAlt \bSpecial{num} \bAltEnd
\bEnd
}

\newcommand{\BnfInstrList}{
\bHead{instr\_list}
  \bStar{instr \bToken{\bs lend}}
\bEnd
}

\newcommand{\BnfInstr}{
\bHead{instr}
  assign \bOr
  declare \bOr
  with\_loop \bOr
  return
\bEnd
}

\newcommand{\BnfAssign}{
\bHead{assign}
  idx \bToken{\bs gets} expr
\bEnd
}

\newcommand{\BnfDeclare}{
\bHead{declare}
  idx \bToken{\bs in} ext\_type
\bEnd
}

\newcommand{\BnfBoolOp}{
\bHead{boolop}
  \bToken{\bs land} \bOr
  \bToken{\bs lor} \bOr
  \bToken{\bs oplus}
\bEnd
}

\newcommand{\BnfBinOp}{
\bHead{binop}
  \bSymb{+} \bOr
  \bSymb{-} \bOr
  \bToken{\bs cdot} \bOr
  \bToken{\bs ll} \bOr
  \bToken{\bs gg} \bOr
  \bToken{\bs mod}
\bEnd
}

\newcommand{\BnfDivide}{
\bHead{divide}
  \bAlt{\bToken{\bs frac}}{\bToken{\bs dfrac}} \bSymb{\{} expr \bSymb{\}}
  \bSymb{\{} expr \bSymb{\}}
\bEnd
}

\newcommand{\BnfFunctionCall}{
\bHead{function\_call}
  \bToken{\bs call} \bSymb{\{} \bSpecial{id} \bSymb{\}} \bSymb{\{}
  \bOpt{idx\_numx
  \bStar{\bSymb{,} idx\_numx }} \bSymb{\}}
\bEnd
}

\newcommand{\BnfSExpr}{
\bHead{sexpr}
  \bAlt{\bToken{\bs lnot}}{\bSymb{-}} sexpr\_op
  \bStar{\bAlt{binop}{boolop} sexpr\_op } \bOr
  \bSymb{(} sexpr \bSymb{)} \bOr
  \bSymb{\{} sexpr \bSymb{\}}
\bEnd
}

\newcommand{\BnfSExprOp}{
\bHead{sexpr\_op}
  \bAlt{\bSpecial{idx\_numx}}{ function\_call}
\bEnd
}

\newcommand{\BnfFilter}{
\bHead{filter}
  \bToken{\bs filter} \bSymb{\{} \bSpecial{id} \bSymb{\^} \bSpecial{\{}
  \bSymb{[} \bSpecial{id} \bSymb{]} \bSpecial{\}} \bSkip \bStar{\bSymb{,}
  \bSpecial{id} \bSymb{\^} \bSpecial{\{} \bSymb{[} \bSpecial{id} \bSymb{]}
  \bSpecial{\}}} \bSkip \bSymb{|} generator \bSymb{\}}
\bEnd
}

\newcommand{\BnfGenArray}{
\bHead{genarray}
 \bToken{\bs genar} \bToken{\bs limits} \bSymb{\^} \bSymb{\{} sexpr \bSymb{\}}
 \bSymb{(} sexpr \bSymb{)}
\bEnd
}

\newcommand{\BnfVector}{
\bHead{vector}
  \bToken{\bs begin} \bSymb{\{} \bToken{tvector} \bSymb{\}} \bSkip
  \bPlus{sexpr\bToken{\bs lend}} \bSkip
  \bToken{\bs end} \bSymb{\{} \bToken{tvector} \bSymb{\}}
\bEnd
}

\newcommand{\BnfMatrix}{
\bHead{matrix}
  \bToken{\bs begin} \bSymb{\{} \bToken{tmatrix} \bSymb{\}}\bSymb{\{}
  \bSpecial{id} \bSymb{\}} \bSkip
  \bPlus{sexpr \bStar{ \bSymb{\&} sexpr } \bToken{\bs lend}} \bSkip
  \bToken{\bs end} \bSymb{\{} \bToken{tmatrix} \bSymb{\}}
\bEnd
}

\newcommand{\BnfExpr}{
\bHead{expr}
  sexpr \bOr
  filter \bOr
  genarray \bOr
  vector \bOr
  matrix
\bEnd
}

\newcommand{\BnfWithLoop}{
\bHead{with\_loop}
  idx \bSymb{|} generator \bToken {\bs gets}
  \bAlt {expr} {with\_loop\_cases}
\bEnd
}

\newcommand{\BnfWithLoopCases}{
\bHead{with\_loop\_cases}
  \bToken{\bs begin} \bSymb{\{} \bToken{cases} \bSymb{\}} \bSkip
  \bPlus{expr \bSymb{\&} generator} \bSkip
  \bPlus{expr \bSymb{\&} \bToken{\bs otherwise}}\bSkip
  \bToken{\bs end} \bSymb{\{} \bToken{cases} \bSymb{\}}
\bEnd
}

\newcommand{\BnfReturn}{
\bHead{return}
  \bToken{\bs return} \bSymb{\{} expr \bSymb{\}}
\bEnd
}

\newcommand{\BnfGenerator}{
\bHead{generator}
  \bToken{\bs forall} \bSpecial{id} \bStar{ \bSymb{,} \bSpecial{id} } \bOr
  \bSpecial{id} \bStar{ \bSymb{,} \bSpecial{id}} \bSymb{:} sexpr \bPlus{comp
  sexpr} \bSkip \bStar{set\_op sexpr \bPlus{comp sexpr}}
\bEnd
}

\newcommand{\BnfComp}{
\bHead{comp}
  \bSymb{<} \bOr
  \bSymb{>} \bOr
  \bToken{\bs leq} \bOr
  \bToken{\bs geq} \bOr
  \bOpt{\bToken{\bs not}} \bSymb{=}
\bEnd
}

\newcommand{\BnfSetOp}{
\bHead{set\_op}
  \bAlt{\bToken{\bs land}}{\bToken{\bs lor}}
\bEnd
}
